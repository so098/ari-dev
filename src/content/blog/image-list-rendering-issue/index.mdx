---
title: 'v1.0.0: “이미지 리스트 렌더링 시 UI 흔들림 문제와 Skeleton 기반 해결 전략”'
description: 'API로 불러온 이미지 리스트 렌더링 시 UI가 흔들리는 이유와 해결 전략을 브라우저 렌더링 관점에서 설명합니다.'
date: '2025-04-24'
tags: ['v1.0.0']
image: './1200x630.png'
authors: ['ari']
---

import Callout from '@/components/Callout.astro'

## 순차 로딩으로 흔들리는 UI, Skeleton으로 바로잡기

### 문제 상황
#### 이미지 리스트 로딩 중 발생한 UI 불일치 문제
이미지 리스트 렌더링은 실제 서비스에서 자주 발생하는 흔한 이슈지만, 단순히 “이미지가 늦게 뜨는 문제”를 넘어 UI 전체의 일관성과 신뢰도에 영향을 줄 수 있습니다.
이 글에서는 이 문제의 구조적 원인을 브라우저 렌더링 관점에서 분석하고,
이를 어떻게 해결했는지를 UX 중심의 전략과 함께 공유하려고 합니다.

API를 통해 이미지 리스트를 불러올 경우, 먼저 도착한 이미지부터 순차적으로 화면에 표시되기 때문에
전체 UI가 한 번에 렌더링되지 않고, 로딩 속도에 따라 이미지가 하나씩 들쭉날쭉 나타나는 현상이 발생할 수 있습니다.
이로 인해 사용자 입장에서는 콘텐츠의 위치가 불안정하게 흔들리거나
화면이 깜빡이는 것처럼 느껴지는 문제가 생기며, 결과적으로 UI의 일관성이 깨지게 됩니다.

이러한 문제를 해결하기 위해, 실제 프로젝트에서 어떤 접근과 구현 방식을 선택했는지를 정리해 보았습니다.

---

### 동적으로 이미지를 불러오는 과정
<Callout title="동적 렌더링 핵심 흐름" variant="note">
JS 실행 -> DOM 변경(필요시) → 브라우저는 해당 영역의 레이아웃을 재 계산(Reflow) → 다시 그림(Paint) → 최종 합성(Composite)
</Callout>

![동적으로 이미지를 불러오는 과정](./js-after-browser-render-image.png)
---
### 동적으로 이미지를 불러올 때, 왜 화면이 흔들릴까?

- 각 이미지의 요청/응답 속도가 다르기 때문에 **렌더링 순서가 일치하지 않을 수 있습니다.**
- 이미지의 `width`, `height`가 지정되지 않았다면, 브라우저는 공간을 확보하지 못하고 로드 시점마다 레이아웃을 재계산(Reflow)을 합니다.
- 이는 UI가 들쭉날쭉하거나 흔들리는 것처럼 보이게 만듭니다.

<Callout title="Reflow가 반복 발생하는 이유" variant="warning">
- API로 받아온 이미지는 각각 다른 시간에 도착하고 크기가 정해지지 않으면 도착할 때마다 **Reflow가 발생**합니다.
- 그로 인해 UI 전체가 **순간적으로 이동하거나 깨진 듯 보일 수 있습니다.**
</Callout>
---

## 이미지 로딩이 UI에 미치는 영향
<img src="/image-road-default.gif" alt="로딩 데모" width="400" />
- API로 받아온 이미지는 JavaScript 실행 후 렌더링되기 때문에,이미지마다 요청 및 로딩 시점이 달라지고, 
각 이미지의 크기를 사전에 알 수 없는 경우 **순차적으로 Reflow가 발생**합니다.
- 이미지 크기를 지정하지 않으면, 로딩 전에 브라우저는 요소의 공간을 확보하지 못합니다.  
사용자 입장에서는 **처음엔 아무것도 없었다가**, 이미지들이 **툭툭 튀어나오듯** 순서 없이 등장하게 됩니다.

- 이 과정에서 다른 콘텐츠가 갑자기 밀리거나 위치가 바뀌는 듯 보이는데,  
이는 브라우저가 **이미지의 크기를 뒤늦게 파악하고 레이아웃을 다시 계산(Reflow)하기 때문**입니다.

- 즉, 사용자에게는 “카드가 갑자기 중구난방으로 나오는 것처럼” 보이지만,  
그 실제 원인은 **초기 공간이 확보되지 않은 데서 시작된 Reflow의 반복**입니다.

<Callout title="결과적으로 나타나는 UX 문제" variant="danger">
- 이미지 크기가 제각각인 것처럼 보이고 화면이 위아래로 밀리며 깜빡이는 현상이 발생합니다.  
- 콘텐츠 인지 흐름이 깨짐 → 사용자가 빠르게 이탈할 가능성이 증가합니다.
</Callout>



---
## 해결 방법
### 방법 1: 모든 이미지 로드가 완료된 이후에 일괄 표시하는 방식
모든 이미지의 로딩이 완료된 후에 전체 UI를 한 번에 표시하는 방식입니다.

**구현 방법**: `Promise.all()`을 사용해 이미지들이 모두 로드될 때까지 기다렸다가 한꺼번에 렌더링합니다.

<img src="/load-all-at-once-image.gif" alt="전체 이미지 한번에 로드 데모" width="400" />
|      |  |
|----------|------|
| 장점  | 레이아웃 유지, UX 안정성 |
| 단점  | 느린 이미지에 전체가 묶일 수 있음 |


<div class="h-px bg-gray-100 my-6"></div>
### 방법 2: 각 이미지에 스켈레톤(Skeleton) UI 적용
이미지 로딩 전, 동일한 크기의 Skeleton UI를 먼저 표시하고, 이미지가 로드되면 교체하는 방식입니다.

**구현 방법**: `<img>` 태그의 onLoad 이벤트를 사용해 이미지가 로드되면 opacity 값과 transition 등을 고려한 부드러운 전환 처리를 하여 Skeleton 위에 자연스럽게 표시되도록 합니다.

<img src="/differently-each-image-load.gif" alt="전체 이미지 한번에 로드 데모" width="400" />
|  |  |
|------|------|
| 장점 | 이미지 로딩 여부와 무관하게 레이아웃을 먼저 보여줄 수 있어 구조 인지에 유리.<br/>콘텐츠를 순차적으로 노출시켜 이탈률을 줄일 수 있음 |
| 단점 | Skeleton 자체는 실제 콘텐츠가 아니기 때문에 시각적 몰입도가 떨어질 수 있음<br/>Skeleton 크기가 정확하지 않으면 Reflow 발생 가능성 |

<Callout title="주의" variant="warning">
Skeleton이 실제 이미지와 다른 크기일 경우,  
이미지가 교체되는 순간 Reflow가 발생해 레이아웃이 흔들릴 수 있습니다.  
→ Skeleton과 이미지의 크기를 동일하게 유지하는 것이 중요합니다.
</Callout>

<div class="h-px bg-gray-100 my-6"></div>
### 방법 3: Progressive Image Loading
사용자에게 이미지를 기다리는 대신 **저해상도 버전을 빠르게 먼저 보여줌으로써 “이미 나왔다”는 심리적 안정을 유도하는 방식**입니다.  
이미지를 완전히 가리는 Skeleton과 달리, **이미지 자체를 흐리게 보여주는 것**이 특징이며, 이후 고해상도 이미지로 자연스럽게 전환됩니다.

**구현 방법**:  
- 저해상도 썸네일 이미지에 Blur 필터를 적용해 먼저 렌더링한 뒤, 고해상도 이미지로 자연스럽게 교체합니다.
- Next.js의 `next/image` 컴포넌트에서는 `placeholder="blur"`와 `blurDataURL` 속성을 사용해 쉽게 구현할 수 있습니다.
- `blurDataURL`은 base64로 인코딩된 저용량 이미지이며, `plaiceholder` 등의 도구를 사용해 생성할 수 있습니다.

<img src="/blur-next-image.gif" alt="블러 이미지 데모" width="400" />
- **React 환경에서는 직접 구현이 복잡**할 수 있으나, **Next.js의 `next/image` 컴포넌트를 사용하면 비교적 쉽게 적용 가능**합니다.

|  |  |
|------|------|
| 장점 | 빠른 피드백 제공 (사용자는 로딩 중임을 인지) <br/>LCP 등 웹 성능 지표 개선에 효과적 |
| 단점 | 직접 구현 시 난이도 높음<br/>서버 또는 빌드 환경에서 이미지 BlurDataURL 처리가 필요할 수 있음 |


---

### 최종 선택 및 적용

최종적으로, 개별 이미지에 Skeleton UI를 적용하는 방식을 선택했습니다.  
프로젝트가 React 기반이라 Progressive Image Loading 방식은 사용하지 않았고,  
Skeleton 처리 방식이 다음과 같은 이유로 더 적합하다고 판단했습니다:

- 리스트형 UI에서 사용자의 이탈을 줄이고, 인지 효율을 높일 수 있음  
- 이미지마다 로딩 타이밍이 달라도 레이아웃이 안정적으로 유지되어 시각적 피로도 감소  
- LCP, CLS 등 웹 성능 지표 개선에도 긍정적인 영향을 줄 수 있음


#### 적용 결과

- **적용 전**:  
  이미지가 순차적으로 들쭉날쭉 표시되면서 콘텐츠 인지 흐름이 끊기고,  
  레이아웃 시프트가 발생해 사용자가 어디를 보고 있어야 할지 혼란을 겪게 됨

- **적용 후**:  
  Skeleton으로 미리 공간을 확보한 후, 이미지가 로딩되면 자연스럽게 전환되어, 
  <br/>콘텐츠 흐름이 유지되며 깔끔하고 안정적인 UI가 완성됨

#### 선택 기준 요약

| 기준 | Skeleton | Progressive |
|------|----------|-------------|
| 구현 복잡도 | 낮음 | 높음 (Next.js 추천) |
| UX 피드백 | 빠름 | 자연스러움 |
| 성능 지표 개선 | CLS 위주 | LCP 위주 |

---
#### 마무리

사용자가 웹사이트를 방문했을 때, 지루함을 느끼지 않도록 하는 것은 중요합니다. 
<br/>사용자가 콘텐츠를 보기 전에 이탈하면 피드백을 받을 기회조차 없기 때문입니다. 
물론 이탈 자체가 피드백일 수 있지만, 그것이 전부가 되어서는 안 됩니다.

Nielsen Norman Group의 연구에 따르면 사용자는 웹 페이지에 10~20초만 머무르며, 이 시간 내에 명확한 가치 제안을 제공하지 않으면 이탈할 가능성이 높다고 합니다.

이런 이유로, 사용자 경험을 고려한 렌더링 방식이 중요합니다. 그렇기 때문에 Skeleton UI나 로딩 스피너와 같은 피드백 요소를 통해 사용자가 로딩 중임을 인지하게 하고, 
콘텐츠가 순차적으로 노출되도록 설계하면 사용자의 이탈률을 줄일 수 있습니다. 
또한, Next.js의 next/image 컴포넌트를 활용한 Progressive Image Loading 기법을 도입하면 부드러운 사용자 경험을 제공할 수도 있습니다.

사용자의 이탈률은 웹사이트의 성공에 직접적인 영향을 미치므로, 다양한 방법으로 사용자의 이탈을 방지하고, 더 나은 피드백을 받을 수 있도록 해야합니다.


---
<details>
<summary>읽어보면 좋은 Tip</summary>
### 기타 방법: 로딩 스피너(Spinner) 보여주기
이미지가 로드되기 전, 각 위치 또는 화면 중앙에 **원형으로 돌아가는 로딩 스피너(Spinner)**를 표시합니다. 이미지가 로드되면 스피너를 숨기고 이미지를 보여줍니다.  

|  |  |
|------|------|
| 장점 | 사용자가 **로딩 중임을 명확하고 빠르게 인식**할 수 있음(Skeleton보다 더 직관적인 피드백 제공) <br/>Skeleton보다 가볍고 빠르게 구현 가능   |
| 단점 | Skeleton처럼 **콘텐츠의 자리 확보**는 되지 않아 로딩 중 UI가 **들쭉날쭉 흔들릴 수 있음 |

<Callout title="언제 이 방법이 특히 유용할까?" variant="tip">
- **사용자가 이탈하기 쉬운 로딩 구간에서** 스피너는 **즉각적으로 ‘기다림’을 인지시켜** 이탈률을 줄이는 데 효과적
- **개별 이미지가 독립적으로 로드되고**, Skeleton보다 **가벼운 피드백이 필요할 때**  
- 이미지 수가 많지 않고, **전체 UI의 자리 확보가 중요하지 않을 때**  
- Skeleton을 사용하기 어려운 디자인이거나, **전체 레이아웃이 유동적인 경우**
</Callout>

---
### 기타 로드 방법: 정적 이미지 로딩과 동적 이미지 로딩
<Callout title="정적 이미지 로딩과 동적 이미지 로딩의 차이" variant="tip">
브라우저는 HTML 문서를 정적으로 파싱할 때, 프리로드 스캐너를 통해 `<img>` 등의 리소스를 미리 탐색하고 요청하여 초기 렌더링 속도를 높일 수 있습니다.  
하지만 API로 데이터를 받아 JavaScript로 이미지를 **동적으로 렌더링**하는 경우, 이 최적화는 작동하지 않습니다.  
또한 프리로드 스캐너가 작동하더라도, **이미지 로딩 속도는 서버 응답 속도, 이미지 크기 등에 따라 달라질 수 있기 때문에**,  
결국 UI가 **순차적으로 흔들리거나, Reflow가 발생하는 상황은 여전히 생길 수 있습니다.**
<Callout title="프리로드 스캐너란?" variant="note">
프리로드 스캐너는 메인 HTML 파서와 별도로 동작하는 “미리보기 역할”을 하고 있습니다.
	- 메인 파서가 DOM 트리를 차근차근 만드는 동안, 프리로드 스캐너는 HTML 문서를 빠르게 훑어보며 병렬로 동작합니다.
	- 주요 역할은 리소스 선탐색(preloading)입니다:**
	- HTML 내 `<link>`, `<img>`, `<script>`, `<video>`, `<audio>` 등 외부 리소스를 사용하는 태그들을 미리 발견합니다.
	- 메인 파서가 해당 태그에 도달하기도 전에, 브라우저가 해당 리소스를 미리 다운로드 요청할 수 있도록 합니다.

즉, 프리로드 스캐너는 렌더링 성능을 높이기 위한 브라우저의 최적화 전략 중 하나로, 스크립트나 이미지 등의 로딩을 앞당겨 병목을 줄이는 데 중요한 역할을 합니다.
</Callout>
</Callout>
</details>

<Callout title="참고 문헌 모음" variant="note">
[Populating the page: how browsers work](https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/How_browsers_work)

[Critical Rendering Path](https://developer.mozilla.org/ko/docs/Web/Performance/Guides/Critical_rendering_path)

[How Long Do Users Stay on Web Pages?](https://www.nngroup.com/articles/how-long-do-users-stay-on-web-pages/)

[브라우저 미리 로드 스캐너와 싸우지 마세요.](https://web.dev/articles/preload-scanner?hl=ko)

[next/image](https://nextjs.org/docs/app/api-reference/components/image)

[plaiceholder](https://plaiceholder.co/docs)
</Callout>